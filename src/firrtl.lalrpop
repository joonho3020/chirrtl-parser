use crate::ast;
use crate::lexer::*;

grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    "indent"           => Token::Indent,
    "dedent"           => Token::Dedent,
    "info"             => Token::Info(<String>),
    "id"               => Token::ID(<i64>),
    " "                => Token::Space,
    "\t"               => Token::Tab,
    "\n"               => Token::Newline,
    "radixint"         => Token::RadixInt(<String>),
    "int"              => Token::IntegerDec(<i64>),
    "identifier"       => Token::Identifier(<String>),
    "string"           => Token::String(<String>),
    "/"                => Token::Slash,
    "["                => Token::LeftSquare,
    "]"                => Token::RightSquare,
    "<"                => Token::LeftAngle,
    ">"                => Token::RightAngle,
    "{"                => Token::LeftBracket,
    "}"                => Token::RightBracket,
    "("                => Token::LeftParenthesis,
    ")"                => Token::RightParenthesis,
    "@"                => Token::AtSymbol,
    "`"                => Token::Backtick,
    "@[["              => Token::AnnoStart,
    "]]"               => Token::AnnoEnd,
    "<<"               => Token::DoubleLeft,
    ">>"               => Token::DoubleRight,
    "clock"            => Token::Clock,
    "reset"            => Token::Reset,
    "async_reset"      => Token::AsyncReset,
    "uint"             => Token::UInt,
    "sint"             => Token::SInt,
    "probe_type"       => Token::ProbeType,
    "probe"            => Token::Probe,
    "analog"           => Token::Analog,
    "fixed"            => Token::Fixed,
    "flip"             => Token::Flip,
    "primop_e2"        => Token::E2Op(<String>),
    "primop_e1"        => Token::E1Op(<String>),
    "primop_e1i1"      => Token::E1I1Op(<String>),
    "primop_e1i2"      => Token::E1I2Op(<String>),
    "mux"              => Token::Mux,
    "validif"          => Token::ValidIf,
    "smem"             => Token::SMem,
    "cmem"             => Token::CMem,
    "write"            => Token::Write,
    "read"             => Token::Read,
    "infer"            => Token::Infer,
    "mport"            => Token::Mport,
    "datatype"         => Token::DataType,
    "depth"            => Token::Depth,
    "read_lat"         => Token::ReadLatency,
    "write_lat"        => Token::WriteLatency,
    "read_under_write" => Token::ReadUnderWrite,
    "wire"             => Token::Wire,
    "reg"              => Token::Reg,
    "reg_reset"        => Token::RegReset,
    "inst"             => Token::Inst,
    "of"               => Token::Of,
    "node"             => Token::Node,
    "invalidate"       => Token::Invalidate,
    "attach"           => Token::Attach,
    "when"             => Token::When,
    "else"             => Token::Else,
    "stop"             => Token::Stop,
    "printf"           => Token::Printf,
    "assert"           => Token::Assert,
    "skip"             => Token::Skip,
    "input"            => Token::Input,
    "output"           => Token::Output,
    "module"           => Token::Module,
    "extmodule"        => Token::ExtModule,
    "intmodule"        => Token::IntModule,
    "defname"          => Token::DefName,
    "parameter"        => Token::Parameter,
    "intrinsic"        => Token::Intrinsic,
    "FIRRTL"           => Token::FIRRTL,
    "version"          => Token::Version,
    "circuit"          => Token::Circuit,
    "connect"          => Token::Connect,
    "public"           => Token::Public,
    "define"           => Token::Define,
    "const"            => Token::Const,
    "symbol"           => Token::Symbol(<String>),
    "."                => Token::Period,
  }
}

pub Info: ast::Info = {
  <info: "info"> => ast::Info(info)
}

// TODO: Add radint case
pub Width: ast::Width = {
    "<" <w: "int"> ">" => ast::Width(w as u32)
};

pub TypeGround: ast::TypeGround = {
    "reset" => ast::TypeGround::Reset,
    "clock" => ast::TypeGround::Clock,
    "async_reset" => ast::TypeGround::AsyncReset,
    "uint" <w: Width> => ast::TypeGround::UInt(Some(w)),
    "uint"            => ast::TypeGround::UInt(None),
    "sint" <w: Width> => ast::TypeGround::SInt(Some(w)),
    "sint"            => ast::TypeGround::SInt(None),
};

pub Fields: ast::Fields = {
    <mut head: Fields> "symbol" <tail: Field> => { head.push(Box::new(tail)); head } ,
    <head: Field> => vec![Box::new(head)],
}

pub Field: ast::Field = {
    <name: Identifier> "symbol" <tpe: Type> => ast::Field::Straight(name, Box::new(tpe)),
    "flip" <name: Identifier> "symbol" <tpe: Type> => ast::Field::Flipped(name, Box::new(tpe)),
};

pub TypeAggregate: ast::TypeAggregate = {
    "{" <fields: Fields> "}" => ast::TypeAggregate::Fields(Box::new(fields)),
    <tpe: Type> "[" <i: "int"> "]"  => ast::TypeAggregate::Array(Box::new(tpe), i),
};

pub Type: ast::Type = {
  <tg: TypeGround> => ast::Type::TypeGround(tg),
  // "const" <tg: TypeGround> => ast::Type::ConstTypeGround(tg),
  <ta: TypeAggregate> => ast::Type::TypeAggregate(Box::new(ta)),
  // "const" <ta: TypeAggregate> => ast::Type::ConstTypeAggregate(Box::new(ta)),
};

pub Identifier: ast::Identifier = {
    <id: "id">                 => ast::Identifier::ID(id as u32),
    <identifier: "identifier"> => ast::Identifier::Name(identifier),
};

pub PrimOp2Expr: ast::PrimOp2Expr = {
    <op: "primop_e2"> => ast::PrimOp2Expr::from(op),
};

pub PrimOp1Expr: ast::PrimOp1Expr = {
    <op: "primop_e1"> => ast::PrimOp1Expr::from(op),
};

pub PrimOp1Expr1Int: ast::PrimOp1Expr1Int = {
    <op: "primop_e1i1"> => ast::PrimOp1Expr1Int::from(op),
};

pub PrimOp1Expr2Int: ast::PrimOp1Expr2Int = {
    <op: "primop_e1i2"> => ast::PrimOp1Expr2Int::from(op),
};

// pub Exprs: Vec<Box<ast::Expr>> = {
//     <head: Exprs> "symbol" <tail: Expr> => head.push(tail),
//     Expr => vec![<>],
// }

// TODO: Take care of radix integers
pub Expr: ast::Expr = {
    <u: "uint"> <w: Width> "(" ")" => ast::Expr::UIntNoInit(w),
    <u: "uint"> <w: Width> "(" <i: "int"> ")" => ast::Expr::UIntInit(w, i),
    <s: "sint"> <w: Width> "(" ")" => ast::Expr::SIntNoInit(w),
    <s: "sint"> <w: Width> "(" <i: "int"> ")" => ast::Expr::SIntInit(w, i),
    <r: Reference> => ast::Expr::Reference(r),
    <m: "mux"> "(" <sel: Expr> "symbol" <exp_true: Expr> "symbol" <exp_false: Expr> ")" => ast::Expr::Mux(Box::new(sel), Box::new(exp_true), Box::new(exp_false)),
    <vif: "validif"> "(" <if_expr: Expr> "symbol" <expr: Expr> ")" => ast::Expr::ValidIf(Box::new(if_expr), Box::new(expr)),
    <op: PrimOp2Expr> "(" <e1: Expr> "symbol" <e2: Expr> ")" => ast::Expr::PrimOp2Expr(op, Box::new(e1), Box::new(e2)),
    <op: PrimOp1Expr> "(" <e1: Expr> => ast::Expr::PrimOp1Expr(op, Box::new(e1)),
    <op: PrimOp1Expr1Int> "(" <e1: Expr> "symbol" <int: "int"> ")" => ast::Expr::PrimOp1Expr1Int(op, Box::new(e1), int as u32),
    <op: PrimOp1Expr2Int> "(" <e1: Expr> "symbol" <int1: "int"> "symbol" <int2: "int"> ")" => ast::Expr::PrimOp1Expr2Int(op, Box::new(e1), int1 as u32, int2 as u32),
};

// pub Refs = Comma<Ref>;

pub Reference: ast::Reference = {
    <name: Identifier> => ast::Reference::Ref(name),
    <id1: Reference> "." <id2: Identifier> => ast::Reference::RefDot(Box::new(id1), id2),
    <id1: Reference> "[" <id2: Identifier> "]" => ast::Reference::RefIdxInt(Box::new(id1), id2),
};

pub Stmts: ast::Stmts = {
    <mut head: Stmts> <tail: Stmt> => { head.push(Box::new(tail)); head } ,
    <head: Stmt> => vec![Box::new(head)],
}

pub Stmt: ast::Stmt = {
  "wire" <name: Identifier> "symbol" <tpe: Type> <info: Info> => ast::Stmt::Wire(name, tpe, info),
  "reg" <name: Identifier> "symbol" <tpe: Type> "symbol" <clk: Expr> <info: Info> => ast::Stmt::Reg(name, tpe, clk, info),
  "reg_reset" <name: Identifier> "symbol" <tpe: Type> "symbol" <clk: Expr> <rst: Expr> <init: Expr> <info: Info> => ast::Stmt::RegReset(name, tpe, clk, rst, init, info),
  "inst" <inst: Identifier> "of" <module: Identifier> <info: Info> => ast::Stmt::Inst(inst, module, info),
  "node" <name: Identifier> "symbol" <expr: Expr> <info: Info> => ast::Stmt::Node(name, expr, info),
  "connect" <sink: Expr> "symbol" <driver: Expr> <info: Info> => ast::Stmt::Connect(sink, driver, info),
  "invalidate" <exp: Expr> <info: Info> => ast::Stmt::Invalidate(exp, info),
  // "when" <cond: Expr> "symbol" <info: Info> "indent" <stmts_true: Stmts> "dedent" "else" "symbol" "indent" <stmts_false: Stmts> "dedent" => ast::Stmt::When(cond, info, stmts_true, Some(stmts_false)),
  // "when" <cond: Expr> "symbol" <info: Info> "indent" <stmts_true: Stmts> "dedent"  => ast::Stmt::When(cond, info, stmts_true, None),
  // "printf" "(" <clk: Expr> "symbol" <clk_val: Expr> "symbol" <msg: "string"> "symbol" <exprs: Exprs> ")" "symbol" <name: Identifier> <info: Info> => ast::Stmt::Printf(clk, clk_val, msg, exprs, info),
  // "printf" "(" <clk: Expr> "symbol" <clk_val: Expr> "symbol" <msg: "string"> "symbol" <exprs: Exprs> ")" <info: Info> => ast::Stmt::Printf(clk, clk_val, msg, exprs, info),
  "assert" "(" <clk: Expr> "symbol" <pred: Expr> "symbol" <cond: Expr> "symbol" <msg: "string"> ")" <info: Info> => ast::Stmt::Assert(clk, pred, cond, msg, info),
}

// pub Keyword: ast::Keyword = {
//     "inst"       => ast::Keyword::Inst,
//     "printf"     => ast::Keyword::Printf,
//     "assert"     => ast::Keyword::Assert,
//     "smem"       => ast::Keyword::SMem,
//     "cmem"       => ast::Keyword::CMem,
//     "of"         => ast::Keyword::Of,
//     "reg"        => ast::Keyword::Reg,
//     "input"      => ast::Keyword::Input,
//     "output"     => ast::Keyword::Output,
//     "invalidate" => ast::Keyword::Invalidate,
//     "mux"        => ast::Keyword::Mux,
//     "stop"       => ast::Keyword::Stop,
//     "depth"      => ast::Keyword::Depth,
//     "write"      => ast::Keyword::Write,
//     "read"       => ast::Keyword::Read,
//     "version"    => ast::Keyword::Version,
//     "probe"      => ast::Keyword::Probe,
//     "module"     => ast::Keyword::Module,
//     "const"      => ast::Keyword::Const,
// };


NewLine<T>: Vec<T> = { // (1)
    <mut v:(<T>)*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Macro for generating Vec<T> from comma separated `T`
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> "symbol")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
